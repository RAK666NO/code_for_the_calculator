import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import re
import math

class ExpressionCalculator:
    """Калькулятор для обработки сложных математических выражений"""
    
    def __init__(self):
        self.operators = {
            '+': (1, lambda a, b: a + b),
            '-': (1, lambda a, b: a - b),
            '*': (2, lambda a, b: a * b),
            '/': (2, lambda a, b: a / b if b != 0 else float('inf')),
            '^': (3, lambda a, b: a ** b),
        }
    
    def calculate_expression(self, expression):
        """Вычисление математического выражения"""
        # Удаляем пробелы
        expression = expression.replace(' ', '')
        
        # Заменяем унарный минус
        expression = re.sub(r'(?<=[\(+\-*/^])-', 'u-', expression)
        if expression.startswith('-'):
            expression = 'u' + expression
        
        # Разбиваем на токены
        tokens = self.tokenize(expression)
        
        # Конвертируем в обратную польскую нотацию
        rpn = self.to_rpn(tokens)
        
        # Вычисляем результат
        return self.evaluate_rpn(rpn)
    
    def tokenize(self, expression):
        """Разбивает выражение на токены"""
        tokens = []
        number = ''
        
        for char in expression:
            if char.isdigit() or char == '.':
                number += char
            else:
                if number:
                    tokens.append(float(number))
                    number = ''
                if char in self.operators or char in '()' or char == 'u':
                    tokens.append(char)
        
        if number:
            tokens.append(float(number))
        
        return tokens
    
    def to_rpn(self, tokens):
        """Конвертирует в обратную польскую нотацию"""
        output = []
        stack = []
        
        for token in tokens:
            if isinstance(token, (int, float)):
                output.append(token)
            elif token == 'u':
                stack.append(token)
            elif token in self.operators:
                while (stack and stack[-1] != '(' and 
                       (stack[-1] == 'u' or 
                        self.operators[stack[-1]][0] >= self.operators[token][0])):
                    output.append(stack.pop())
                stack.append(token)
            elif token == '(':
                stack.append(token)
            elif token == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                stack.pop()  # Удаляем '('
                if stack and stack[-1] == 'u':
                    output.append(stack.pop())
        
        while stack:
            output.append(stack.pop())
        
        return output
    
    def evaluate_rpn(self, rpn):
        """Вычисляет выражение в обратной польской нотации"""
        stack = []
        
        for token in rpn:
            if isinstance(token, (int, float)):
                stack.append(token)
            elif token == 'u':
                stack.append(-stack.pop())
            elif token in self.operators:
                b = stack.pop()
                a = stack.pop()
                result = self.operators[token][1](a, b)
                stack.append(result)
        
        return stack[0] if stack else 0

class AdvancedCalculator(ExpressionCalculator):
    """Продвинутый калькулятор с научными функциями"""
    
    def __init__(self):
        super().__init__()
        self.operators.update({
            '%': (2, lambda a, b: a % b if b != 0 else float('inf'), "остаток"),
        })
        
        self.functions = {
            'sqrt': (1, lambda x: math.sqrt(x) if x >= 0 else float('nan')),
            'sin': (1, lambda x: math.sin(math.radians(x))),
            'cos': (1, lambda x: math.cos(math.radians(x))),
            'tan': (1, lambda x: math.tan(math.radians(x))),
            'log': (1, lambda x: math.log10(x) if x > 0 else float('nan')),
            'ln': (1, lambda x: math.log(x) if x > 0 else float('nan')),
            'exp': (1, lambda x: math.exp(x)),
            'abs': (1, lambda x: abs(x)),
        }
        
        self.constants = {
            'π': math.pi,
            'e': math.e,
        }
        
        self.history = []
    
    def calculate(self, expression):
        """Вычисляет выражение с поддержкой функций"""
        try:
            expr = expression.replace(' ', '')
            
            # Заменяем константы
            for const, value in self.constants.items():
                expr = expr.replace(const, str(value))
            
            # Заменяем функции
            for func_name in self.functions:
                if func_name in expr:
                    # Находим функцию и её аргументы
                    pattern = fr'{func_name}\(([^)]+)\)'
                    matches = re.findall(pattern, expr)
                    for match in matches:
                        arg_result = self.calculate_expression(match)
                        expr = expr.replace(f'{func_name}({match})', str(arg_result))
            
            # Вычисляем оставшееся выражение
            result = self.calculate_expression(expr)
            
            # Сохраняем в историю
            self.history.append((expression, result))
            if len(self.history) > 20:
                self.history.pop(0)
                
            return result
            
        except Exception as e:
            raise ValueError(f"Ошибка вычисления: {str(e)}")

class CalculatorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Научный Калькулятор v2.0")
        self.root.geometry("800x600")
        self.root.minsize(600, 500)
        
        # Создаем калькулятор
        self.calc = AdvancedCalculator()
        
        # Сначала создаем переменные
        self.current_expression = tk.StringVar()
        self.result_var = tk.StringVar(value="0")
        
        # Настройка стилей
        self.setup_styles()
        
        # Создаем интерфейс
        self.create_widgets()
        
    def setup_styles(self):
        """Настройка стилей для кнопок"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # Цвета
        self.bg_color = "#f0f0f0"
        self.display_bg = "#ffffff"
        self.button_bg = "#e0e0e0"
        self.operator_bg = "#ff9500"
        self.function_bg = "#4a9eff"
        self.history_bg = "#f8f8f8"
        
        self.root.configure(bg=self.bg_color)
        
    def create_widgets(self):
        """Создание виджетов интерфейса"""
        # Основной контейнер
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Конфигурация расширения
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Дисплей и результат
        self.create_display(main_frame)
        
        # История вычислений
        self.create_history(main_frame)
        
        # Кнопки калькулятора
        self.create_buttons(main_frame)
        
    def create_display(self, parent):
        """Создание дисплея калькулятора"""
        display_frame = ttk.Frame(parent)
        display_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        display_frame.columnconfigure(0, weight=1)
        
        # Поле ввода выражения
        self.entry = ttk.Entry(
            display_frame, 
            textvariable=self.current_expression,
            font=('Arial', 16),
            justify='right'
        )
        self.entry.grid(row=0, column=0, sticky=(tk.W, tk.E), ipady=10)
        self.entry.bind('<Return>', lambda e: self.calculate())
        self.entry.bind('<KP_Enter>', lambda e: self.calculate())
        
        # Поле результата
        result_label = ttk.Label(
            display_frame,
            textvariable=self.result_var,
            font=('Arial', 24, 'bold'),
            background=self.display_bg,
            relief='solid',
            anchor='e',
            padding=10
        )
        result_label.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(5, 0), ipady=5)
        
    def create_history(self, parent):
        """Создание области истории"""
        history_frame = ttk.LabelFrame(parent, text="История вычислений", padding="5")
        history_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 5))
        history_frame.columnconfigure(0, weight=1)
        history_frame.rowconfigure(0, weight=1)
        
        # Текстовое поле истории
        self.history_text = scrolledtext.ScrolledText(
            history_frame,
            height=10,
            font=('Courier', 10),
            bg=self.history_bg,
            state='disabled'
        )
        self.history_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
    def create_buttons(self, parent):
        """Создание кнопок калькулятора"""
        buttons_frame = ttk.Frame(parent)
        buttons_frame.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(5, 0))
        
        # Кнопки расположены в сетке 6x5
        buttons = [
            # Первый ряд - функции
            ('sin(', 'sin(', self.function_bg),
            ('cos(', 'cos(', self.function_bg),
            ('tan(', 'tan(', self.function_bg),
            ('√(', 'sqrt(', self.function_bg),
            ('ln(', 'ln(', self.function_bg),
            
            # Второй ряд - функции
            ('log(', 'log(', self.function_bg),
            ('exp(', 'exp(', self.function_bg),
            ('abs(', 'abs(', self.function_bg),
            ('π', 'π', self.function_bg),
            ('e', 'e', self.function_bg),
            
            # Третий ряд - цифры и операторы
            ('7', '7', self.button_bg),
            ('8', '8', self.button_bg),
            ('9', '9', self.button_bg),
            ('/', '/', self.operator_bg),
            ('C', 'C', '#ff3b30'),
            
            # Четвертый ряд
            ('4', '4', self.button_bg),
            ('5', '5', self.button_bg),
            ('6', '6', self.button_bg),
            ('*', '*', self.operator_bg),
            ('(', '(', self.button_bg),
            
            # Пятый ряд
            ('1', '1', self.button_bg),
            ('2', '2', self.button_bg),
            ('3', '3', self.button_bg),
            ('-', '-', self.operator_bg),
            (')', ')', self.button_bg),
            
            # Шестой ряд
            ('0', '0', self.button_bg),
            ('.', '.', self.button_bg),
            ('%', '%', self.operator_bg),
            ('+', '+', self.operator_bg),
            ('^', '^', self.operator_bg),
            
            # Седьмой ряд - специальные кнопки
            ('⌫', 'backspace', '#8e8e93'),
            ('±', 'negate', self.button_bg),
            ('=', '=', '#34c759'),
            ('История', 'history', '#5ac8fa'),
            ('Очистить', 'clear', '#ff9500'),
        ]
        
        # Создаем кнопки
        for i, (text, command, color) in enumerate(buttons):
            row = i // 5
            col = i % 5
            
            if command == '=':
                btn = tk.Button(
                    buttons_frame,
                    text=text,
                    font=('Arial', 14, 'bold'),
                    bg=color,
                    fg='white',
                    command=lambda c=command: self.button_click(c),
                    height=2,
                    width=6
                )
            elif command in ['history', 'clear']:
                btn = tk.Button(
                    buttons_frame,
                    text=text,
                    font=('Arial', 10),
                    bg=color,
                    fg='white',
                    command=lambda c=command: self.button_click(c),
                    height=2,
                    width=6
                )
            else:
                btn = tk.Button(
                    buttons_frame,
                    text=text,
                    font=('Arial', 12),
                    bg=color,
                    fg='black' if color == self.button_bg else 'white',
                    command=lambda c=command: self.button_click(c),
                    height=2,
                    width=6
                )
            
            btn.grid(row=row, column=col, padx=2, pady=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Настройка расширения строк и столбцов
        for i in range(7):
            buttons_frame.rowconfigure(i, weight=1)
        for i in range(5):
            buttons_frame.columnconfigure(i, weight=1)
    
    def button_click(self, command):
        """Обработка нажатия кнопок"""
        current = self.current_expression.get()
        
        if command.isdigit() or command in '+-*/.^%()πe':
            self.current_expression.set(current + command)
            
        elif command in ['sin(', 'cos(', 'tan(', 'sqrt(', 'log(', 'ln(', 'exp(', 'abs(']:
            self.current_expression.set(current + command)
            
        elif command == 'C':
            self.current_expression.set('')
            self.result_var.set('0')
            
        elif command == 'backspace':
            self.current_expression.set(current[:-1])
            
        elif command == 'negate':
            if current and current[0] == '-':
                self.current_expression.set(current[1:])
            else:
                self.current_expression.set('-' + current)
                
        elif command == '=':
            self.calculate()
            
        elif command == 'history':
            self.show_history_dialog()
            
        elif command == 'clear':
            self.calc.history.clear()
            self.update_history_display()
            
        # Устанавливаем фокус обратно на поле ввода
        self.entry.focus_set()
    
    def calculate(self):
        """Вычисление выражения"""
        expression = self.current_expression.get().strip()
        
        if not expression:
            return
        
        try:
            result = self.calc.calculate(expression)
            
            if math.isnan(result):
                self.result_var.set("Ошибка: недопустимая операция")
            elif result == float('inf'):
                self.result_var.set("Ошибка: деление на ноль")
            elif result == float('-inf'):
                self.result_var.set("Ошибка: переполнение")
            else:
                # Форматируем результат
                if isinstance(result, float):
                    # Проверяем, целое ли число
                    if result.is_integer():
                        result_str = str(int(result))
                    else:
                        # Ограничиваем количество знаков после запятой
                        result_str = f"{result:.10g}"
                else:
                    result_str = str(result)
                    
                self.result_var.set(result_str)
                self.update_history_display()
                
        except ValueError as e:
            messagebox.showerror("Ошибка", str(e))
        except ZeroDivisionError:
            messagebox.showerror("Ошибка", "Деление на ноль")
        except Exception as e:
            messagebox.showerror("Ошибка", f"Неожиданная ошибка: {str(e)}")
            
        # Очищаем поле ввода после вычисления
        self.current_expression.set('')
    
    def update_history_display(self):
        """Обновление отображения истории"""
        self.history_text.configure(state='normal')
        self.history_text.delete(1.0, tk.END)
        
        if not self.calc.history:
            self.history_text.insert(tk.END, "История пуста\n")
        else:
            for expr, result in reversed(self.calc.history):
                if math.isnan(result):
                    result_str = "Ошибка: недопустимая операция"
                elif result == float('inf'):
                    result_str = "Ошибка: деление на ноль"
                elif result == float('-inf'):
                    result_str = "Ошибка: переполнение"
                else:
                    if isinstance(result, float):
                        if result.is_integer():
                            result_str = str(int(result))
                        else:
                            result_str = f"{result:.6g}"
                    else:
                        result_str = str(result)
                
                # Обрезаем длинные выражения для лучшего отображения
                display_expr = expr[:30] + "..." if len(expr) > 30 else expr
                self.history_text.insert(tk.END, f"{display_expr} = {result_str}\n")
        
        self.history_text.configure(state='disabled')
        self.history_text.see(tk.END)
    
    def show_history_dialog(self):
        """Показ диалога с полной историей"""
        if not self.calc.history:
            messagebox.showinfo("История", "История вычислений пуста")
            return
        
        history_window = tk.Toplevel(self.root)
        history_window.title("Полная история вычислений")
        history_window.geometry("500x400")
        
        # Делаем окно модальным
        history_window.transient(self.root)
        history_window.grab_set()
        
        # Основной фрейм
        main_frame = ttk.Frame(history_window, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Текстовое поле с историей
        text_widget = scrolledtext.ScrolledText(
            main_frame,
            font=('Courier', 10),
            wrap=tk.WORD
        )
        text_widget.pack(fill=tk.BOTH, expand=True)
        
        # Заполняем историю
        for i, (expr, result) in enumerate(reversed(self.calc.history), 1):
            if math.isnan(result):
                result_str = "Ошибка: недопустимая операция"
            elif result == float('inf'):
                result_str = "Ошибка: деление на ноль"
            elif result == float('-inf'):
                result_str = "Ошибка: переполнение"
            else:
                if isinstance(result, float):
                    if result.is_integer():
                        result_str = str(int(result))
                    else:
                        result_str = f"{result:.10g}"
                else:
                    result_str = str(result)
            
            text_widget.insert(tk.END, f"{i:3}. {expr}\n")
            text_widget.insert(tk.END, f"     = {result_str}\n")
            text_widget.insert(tk.END, "-" * 50 + "\n")
        
        text_widget.configure(state='disabled')
        
        # Фрейм с кнопками
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Кнопка закрытия
        close_btn = ttk.Button(
            button_frame,
            text="Закрыть",
            command=history_window.destroy
        )
        close_btn.pack(side=tk.RIGHT)
        
        # Кнопка очистки истории
        clear_btn = ttk.Button(
            button_frame,
            text="Очистить историю",
            command=lambda: [self.calc.history.clear(), history_window.destroy(), self.update_history_display()]
        )
        clear_btn.pack(side=tk.LEFT)
    
    def show_help(self):
        """Показ справки"""
        help_text = """
НАУЧНЫЙ КАЛЬКУЛЯТОР v2.0

ОПЕРАТОРЫ:
+ - сложение      - - вычитание
* - умножение     / - деление
^ - степень       % - остаток от деления

ФУНКЦИИ:
sin() - синус (в градусах)
cos() - косинус (в градусах)
tan() - тангенс (в градусах)
sqrt() - квадратный корень
log() - десятичный логарифм
ln() - натуральный логарифм
exp() - экспонента
abs() - модуль числа

КОНСТАНТЫ:
π - число Пи (3.14159...)
e - число Эйлера (2.71828...)

ПРИМЕРЫ:
sin(30) + cos(60) = 1.0
sqrt(16) * 2 = 8.0
2^3 + 4*5 - 10/2 = 23.0

СПЕЦИАЛЬНЫЕ КНОПКИ:
C - очистить поле ввода
⌫ - удалить последний символ
± - изменить знак
= - вычислить выражение (или Enter)
История - просмотр полной истории
Очистить - очистка истории

ГОРЯЧИЕ КЛАВИШИ:
Enter - вычислить выражение
Esc - очистить поле ввода
Backspace - удалить символ
        """
        
        messagebox.showinfo("Справка", help_text)
    
    def show_about(self):
        """Информация о программе"""
        about_text = """Научный калькулятор v2.0

Функции:
- Поддержка сложных математических выражений
- Научные функции (тригонометрия, логарифмы)
- История вычислений
- Графический интерфейс
- Работает на всех операционных системах

Автор: AI Assistant
Версия: 2.0
"""
        messagebox.showinfo("О программе", about_text)

def main():
    """Запуск приложения"""
    root = tk.Tk()
    app = CalculatorGUI(root)
    
    # Создаем меню
    menubar = tk.Menu(root)
    root.config(menu=menubar)
    
    # Меню Файл
    file_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Файл", menu=file_menu)
    file_menu.add_command(label="Очистить историю", 
                         command=lambda: [app.calc.history.clear(), app.update_history_display()])
    file_menu.add_separator()
    file_menu.add_command(label="Выход", command=root.quit)
    
    # Меню Правка
    edit_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Правка", menu=edit_menu)
    edit_menu.add_command(label="Очистить поле ввода", 
                         command=lambda: app.current_expression.set(''))
    edit_menu.add_command(label="Копировать результат", 
                         command=lambda: root.clipboard_clear() or root.clipboard_append(app.result_var.get()))
    
    # Меню Вид
    view_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Вид", menu=view_menu)
    view_menu.add_command(label="Показать историю", command=app.show_history_dialog)
    
    # Меню Помощь
    help_menu = tk.Menu(menubar, tearoff=0)
    menubar.add_cascade(label="Помощь", menu=help_menu)
    help_menu.add_command(label="Справка", command=app.show_help)
    help_menu.add_command(label="О программе", command=app.show_about)
    
    # Обработка горячих клавиш
    root.bind('<Return>', lambda e: app.calculate())
    root.bind('<KP_Enter>', lambda e: app.calculate())
    root.bind('<Escape>', lambda e: app.current_expression.set(''))
    root.bind('<BackSpace>', lambda e: app.button_click('backspace'))
    
    # Устанавливаем фокус на поле ввода
    app.entry.focus_set()
    
    root.mainloop()

if __name__ == "__main__":
    main()
